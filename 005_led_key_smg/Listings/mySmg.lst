C251 COMPILER V5.60.0,  mySmg                                                              05/01/25  22:07:33  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE mySmg
OBJECT MODULE PLACED IN .\Objects\mySmg.obj
COMPILER INVOKED BY: C:\Software\Keilv5\Keil\Core\C251\BIN\C251.EXE Driver\mySmg.c XSMALL BROWSE INCDIR(.\App;.\COMM;.\D
                    -river;.\User;..\005_) DEBUG PRINT(.\Listings\mySmg.lst) OBJECT(.\Objects\mySmg.obj) 

stmt  level    source

    1          #include "mySmg.h"
    2          unsigned char  smg[] =
    3          {
    4          0xc0, //0
    5          0xf9, //1
    6          0xa4, //2
    7          0xb0, //3
    8          0x99, //4
    9          0x92, //5
   10          0x82, //6
   11          0xf8, //7
   12          0x80, //8
   13          0x90, //9
   14          0x88, //A
   15          0x83, //b
   16          0xc6, //C
   17          0xa1, //d
   18          0x86, //E
   19          0x8e //F
   20          };
   21          
   22          u8 dis_buf[8]={0,0,0,0,0,0,0,0};
   23          char dis_str[10];
   24          //**************************************************************//
   25          void disp_scan()
   26          {
   27   1          static u8 i=0;                                // 使用静态变量 i 记忆当前扫描位置
   28   1          P0=0;                                         // 关闭所有数码管
   29   1          gate(WEI);                                    // 设置位选信号
   30   1          P0=dis_buf[i];                                // 显示当前位数码管的数据
   31   1          gate(DUAN);                                   // 设置段选信号
   32   1          P0=1<<i;                                      // 选择当前位数码管
   33   1          gate(WEI);                                    // 设置位选信号
   34   1          if(++i==8)i=0;                                // 更新扫描位置，若达到最大值则重置为0
   35   1      }
   36          //**************************************************************//
   37          void disp_proc()
   38          {
   39   1          u8 i,j,tmp=0;                                 // 初始化索引变量和临时变量
   40   1          for(i=0,j=0;i<8;i++,j++)                          // 循环处理每一位数码管
   41   1          {
   42   2              switch(dis_str[j])                          // 根据字符设置对应的数码管显示值
   43   2              {
   44   3                  case '0':tmp=smg[0];break;              // 字符 '0' 对应的数码管显示值
   45   3                  case '1':tmp=smg[1];break;              // 字符 '1' 对应的数码管显示值
   46   3                  case '2':tmp=smg[2];break;              // 字符 '2' 对应的数码管显示值
   47   3                  case '3':tmp=smg[3];break;              // 字符 '3' 对应的数码管显示值
   48   3                  case '4':tmp=smg[4];break;              // 字符 '4' 对应的数码管显示值
   49   3                  case '5':tmp=smg[5];break;              // 字符 '5' 对应的数码管显示值
   50   3                  case '6':tmp=smg[6];break;              // 字符 '6' 对应的数码管显示值
   51   3                  case '7':tmp=smg[7];break;              // 字符 '7' 对应的数码管显示值
   52   3                  case '8':tmp=smg[8];break;              // 字符 '8' 对应的数码管显示值
   53   3                  case '9':tmp=smg[9];break;              // 字符 '9' 对应的数码管显示值
   54   3                  case 'A':tmp=smg[10];break;             // 字符 'A' 对应的数码管显示值
   55   3                  case 'b':tmp=smg[11];break;             // 字符 'b' 对应的数码管显示值
   56   3                  case 'C':tmp=smg[12];break;             // 字符 'C' 对应的数码管显示值
   57   3                  case 'd':tmp=smg[13];break;             // 字符 'd' 对应的数码管显示值
   58   3                  case 'E':tmp=smg[14];break;             // 字符 'E' 对应的数码管显示值
C251 COMPILER V5.60.0,  mySmg                                                              05/01/25  22:07:33  PAGE 2   

   59   3                  case 'F':tmp=smg[15];break;             // 字符 'F' 对应的数码管显示值
   60   3                  case '-':tmp=0xbf;break;                // 字符 '-' 对应的数码管显示值
   61   3                  default:tmp=0xff;break;                 // 默认情况下的数码管显示值
   62   3              }
   63   2              if(dis_str[j+1]=='.')                       // 检查下一个字符是否为小数点
   64   2              {
   65   3                  tmp&=0x7f;                              // 如果有小数点，则点亮小数点
   66   3                  j++;                                    // 跳过小数点字符
   67   3              }
   68   2              dis_buf[i]=tmp;                             // 将处理后的值存入显示缓冲区
   69   2          }
   70   1      }
   71          //**************************************************************//
   72          
   73          
   74          
   75          float  temp12 = 123.123;                        
   76          u8 f_wei=0;//smg闪烁标志
   77          void smg_proc()
   78          {
   79   1      
   80   1      
   81   1          switch(cj.state)                                // 根据状态选择不同的显示格式
   82   1          {
   83   2              case 10:
   84   2                  if(f_wei)
   85   2                      sprintf(dis_str,"F%02u-%02ubb",cj.m,cj.s); // 格式化字符串，显示频率和时间
   86   2                  else
   87   2                      sprintf(dis_str,"   -%02ubb",cj.s);         // 格式化字符串，显示时间
   88   2                  break;
   89   2                      break;
   90   2              case 20:
   91   2                  if(f_wei)
   92   2                      sprintf(dis_str,"d    %3u",cj.key);          // 格式化字符串，显示按键值
   93   2                  else
   94   2                      sprintf(dis_str,"E  %5u",cj.freq);           // 格式化字符串，显示频率
   95   2                  break;
   96   2              case 30:sprintf(dis_str,"b%3.1f %3u",cj.t,cj.d);break; // 格式化字符串，显示温度和距离
   97   2              case 40:sprintf(dis_str,"A    %3u",cj.ad);break;     // 格式化字符串，显示AD值
   98   2          }
   99   1          disp_proc();                                    // 调用 disp_proc 函数进行显示处理
  100   1      }
  101          
  102          
  103          
  104          
  105          
  106          
  107          
  108                                  
  109                                  
  110                          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       604     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        40     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
C251 COMPILER V5.60.0,  mySmg                                                              05/01/25  22:07:33  PAGE 3   

  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       110     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
